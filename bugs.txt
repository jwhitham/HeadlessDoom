
Classification of Doom source code bugs


# DSB-1 - Missing explicit integer types

In some C compilers, you can write `static x` or `register x`
and `int` is implicit. For example:

     static nexttic = 0;

# DSB-2 - Ambiguous assignment with post/pre-increment

A single statement combines two assignments, e.g.

     eventhead = (++eventhead)&(MAXEVENTS-1);

# DSB-3 - Assumption that pointers are 32-bit

Generally, this takes the form of casting pointers to/from integers,
but in some places a size of 4 bytes is explicitly used when calculating
memory sizes.

    statcopy = (void*)atoi(myargv[p+1]);
    return (int)&(((doomdata_t *)0)->cmds[netbuffer->numtics]); 

# DSB-4 - Assumption that char is signed

On x86, `char` is conventionally a signed type, but the C standard
does not specify this, and on other platforms, e.g. ARM, it is unsigned.

    char	forwardmove;	// *2048 for move

# DSB-5 - Headless Doom should play demos rather than an interactive game

`D_DoAdvanceDemo` and `IdentifyVersion` are replaced by functions
in the `headless.c` test harness file, so that Doom is driven through
the DDQ demo files without any user interaction. This feature is
activated when `HEADLESS` is defined.

# DSB-6 - Replace system-specific defines, header files

Linux Doom used various system-specific headers such as `unistd.h`
and defines such as `NORMALUNIX` and `LINUX`. These appeared in many
source files. They are removed, and generally replaced by including
`headless.h` if `HEADLESS` is defined.

Aside from bug fixes, the source code will compile in the same way as
vanilla Linux Doom if `-DNORMALUNIX -DLINUX` are used in `CFLAGS`
without `-DHEADLESS`.

# DSB-7 - Log messages for the start of a new demo or a new level

Headless Doom logs these important events using modifications in
`g_game.c`.

# DSB-8 - GameMission_t / GameMode_t mixup

Tests of `gamemode` wrongly used enumeration values from
`GameMission_t`, causing compilation errors. The original
behaviour is preserved.

# DSB-9 - Incorrect memset bounds in G_DoLoadLevel

`memset` functions in `G_DoLoadLevel` should clear all
of the provided memory area, but instead they clear
only a small part (often the size of a pointer). For example:

    memset (players[i].frags,0,sizeof(players[i].frags)); 

The correct size is provided.

# DSB-10 - Pointer targets differ in signedness

Both `strcmp` parameters are `char *`, but `unsigned char`
was used instead. Example:

    if (strcmp (save_p, vcheck)) 

Resolved by a type cast.

# DSB-11 - System-specific networking, sound and video code

Headless Doom is not interactive and does not use any network,
video or sound, so the whole contents of `i_net.c`
`i_video.c` and `i_sound.c` are removed by `#ifndef HEADLESS`.
Functions in these files are replaced in `headless.c`,
mostly with empty stubs.

# DSB-12 - Potentially non-deterministic code

Code that accesses a timer or real-time clock is non-deterministic
and will affect the benchmark's operation in various ways. Settings
the `singletics` flag will lead to correct demo playback (as in
vanilla Linux Doom) but won't control all effects. For example,
the screen wipe effect as a new level is loaded is also dependent on
a timer. Therefore, in Headless Doom, calls relating to timing
are replaced by stubs.

Similarly, code that accesses configuration files, saved games
and command-line parameters is replaced by stubs. These inputs
could affect benchmark operation. Configuration file defaults are
replaced by constant values where necessary.

# DSB-13 - NULL sentinel required for sprnames table

The `sprnames` table in `info.c` has a fixed size (`NUMSPRITES`)
but this size is not used by `R_InitSpriteDefs` when reading the
table. Instead, `R_InitSpriteDefs` looks for a NULL value at the
end. This isn't always present, as the C code does not specify it,
and it may just be a matter of chance whether the bytes following
`sprnames` are NULL or not.

# DSB-14 - Possible sprintf overflows for WAD file lump names

`sprintf` is not given a maximum buffer size. Because of the potential
risk of buffer overflow, some C compilers now analyse `sprintf` calls
to determine if memory beyond the end of the buffer might be
overwritten. This can include analysis of the maximum size of
integers and strings that are substituted, e.g. with `%i` or `%s`.

This affects Doom in many places, mostly relating to finding resources
within the WAD file, as each resource has an 1..8-byte key. When
these keys are generated using `sprintf`, the compiler may attempt to
check that more than 9 bytes will not be written (as `sprintf` also
writes a terminating nul byte). Due to a lack of information about the
true bounds of variables, the compiler must pessimistically overestimate
the possible size of string: for example, `"map%i"` would overflow if
there were more than 99999 maps. To deal with these problems in one place,
`M_LumpSprintf` has been added to `m_misc.c` as a replacement for
`sprintf` which is intended specifically for WAD file keys.

# DSB-15 - Possible sprintf overflows in other places

`sprintf` is also used in other places without correct bounding.
For example, the names of save games, printed by the Quick Load feature,
might overflow the buffer.

    char    tempstring[80];
    sprintf(tempstring,QSPROMPT,savegamestrings[quickSaveSlot]);

Calls to `snprintf` are used instead, with an explicit buffer size.

# DSB-16 - Use of fcntl.h and unistd.h for file I/O

Doom used file I/O functions such as `read` and `open`
which are not part of standard C. These functions are available in many
C libraries and are a de-facto standard as well as being part of
POSIX, but they are not universal, and there are differences in
the parameters and flags accepted, e.g. `O_BINARY`.

In Headless Doom they are replaced by `stdio.h` functions
i.e. `fread`, `fopen`, etc., or removed entirely in the case
of `M_ReadFile`, which is never used.

# DSB-17 - Namespace clash for "open"

Doom has an enumerated type named `vldoor_e` which defines `open`
as one of the actions relating to doors. This should not clash with
anything in the C library, since the headers that conventionally
declare `open` are not `#include`d. However, as `open` isn't really
part of the C standard, `open` may be
declared anyway. For example, the Termux version of `stdio.h` defines `open`
[here](https://github.com/termux/termux-packages/blob/57ddad99366c5b84d126b0c72fbb14cc315f0427/ndk-patches/23c/stdio.h.patch#L54).

To reduce such problems, `open` is renamed to `dopen`.

# DSB-18 - Uninitialised local variables

Some functions contain local variables that might be used before being
assigned, as a result of an unexpected code path being taken. For
example, in `EV_BuildStairs`, the value of the local variable `stairsize` will be
uninitialised if `type` is not one of two expected values.

Although other values of `type` may be impossible, the compiler cannot
determine this, and initialisation is a good idea to prevent unpredictable
behaviour.

# DSB-19 - Boolean and bitwise operators mixed with unclear operator precedence

GCC warns about expressions that mix Boolean and bitwise operators
and also rely on potentially unexpected operator precedence orders. For example:

    if (!s2->lines[i]->flags & ML_TWOSIDED) ...

This expression does have a well-defined meaning in C, but it depends
on operator precedence and might not be intended. Adding more brackets
removes possible ambiguity, making the meaning clearer.

    if (!(s2->lines[i]->flags & ML_TWOSIDED)) ...

# DSB-20 - Unary minus used with unsigned types

MSVC does not allow the use of the unary `-` operator with an unsigned type, e.g.

    angle2 = -clipangle;

As unsigned types cannot be negative, the use of `-` is not meaningful in
arithmetic terms, though it is still a useful way to force
an overflow around zero, so (for instance) 0x1 becomes 0xffffffff. Subtracting
from 0 is equivalent and accepted by the compiler.

    angle2 = 0-clipangle;


# DSB-21 - drawing after the end of a short column


# DSB-22 - drawing before the beginning of a short column




diff --git a/headless_doom/r_draw.c b/headless_doom/r_draw.c
index 0145044..d36a977 100644
--- a/headless_doom/r_draw.c
+++ b/headless_doom/r_draw.c
@@ -132,6 +132,17 @@ void R_DrawColumn (void)
     fracstep = dc_iscale; 
     frac = dc_texturemid + (dc_yl-centery)*fracstep; 
 
+    // JWh: If the position is before the start of the column, fill
+    // with black to avoid accessing undefined memory (before dc_source).
+    // Issue first seen in E1M1 at headless_count 191 x 149 y 85.
+    while (frac < 0) {
+        *dest = 0;
+        dest += SCREENWIDTH;
+        frac += fracstep;
+        count --;
+        if (count < 0) return;
+    }
+
     // Inner loop that does the actual texture mapping,
     //  e.g. a DDA-lile scaling.
     // This is as fast as it gets.
@@ -461,7 +472,7 @@ void R_InitTranslationTables (void)
     int		i;
 	
     translationtables = Z_Malloc (256*3+255, PU_STATIC, 0);
-    translationtables = (byte *)(( (int)translationtables + 255 )& ~255);
+    translationtables = (byte *)(( (intptr_t)translationtables + 255 )& ~255); // JWh - 64-bit compat
     
     // translate just the 16 green colors
     for (i=0 ; i<256 ; i++)
diff --git a/headless_doom/r_main.c b/headless_doom/r_main.c
index ad942c7..d7f1339 100644
--- a/headless_doom/r_main.c
+++ b/headless_doom/r_main.c
@@ -325,7 +325,7 @@ R_PointToAngle
 	    if (x>y)
 	    {
 		// octant 8
-		return -tantoangle[SlopeDiv(y,x)];
+		return 0-tantoangle[SlopeDiv(y,x)]; // JWh - MSVC rejects unary minus with unsigned types
 	    }
 	    else
 	    {
@@ -453,8 +453,9 @@ void R_InitPointToAngle (void)
 fixed_t R_ScaleFromGlobalAngle (angle_t visangle)
 {
     fixed_t		scale;
-    int			anglea;
-    int			angleb;
+    unsigned anglea; // JWh - need to use logical right shift for finesine
+    unsigned angleb; // lookup, otherwise array index is negative. Issue
+                     // first seen in E1M2 headless_count 1098 x 61 y 66
     int			sinea;
     int			sineb;
     fixed_t		num;
diff --git a/headless_doom/r_segs.c b/headless_doom/r_segs.c
index 1962d92..28b1582 100644
--- a/headless_doom/r_segs.c
+++ b/headless_doom/r_segs.c
@@ -210,7 +210,7 @@ void R_RenderSegLoop (void)
     int			yl;
     int			yh;
     int			mid;
-    fixed_t		texturecolumn;
+    fixed_t		texturecolumn = 0; // JWh - ensure initialised
     int			top;
     int			bottom;
 
@@ -263,6 +263,14 @@ void R_RenderSegLoop (void)
 	{
 	    // calculate texture offset
 	    angle = (rw_centerangle + xtoviewangle[rw_x])>>ANGLETOFINESHIFT;
+
+	    // JWh - if the line is almost aligned with the camera, the
+	    // angle is undefined. Prevent an overflow. Issue first seen
+	    // in E1M2 headless_count 1097 x 61 y 84
+	    if (angle >= (FINEANGLES / 2)) {
+		angle = 0;
+	    }
+
 	    texturecolumn = rw_offset-FixedMul(finetangent[angle],rw_distance);
 	    texturecolumn >>= FRACBITS;
 	    // calculate lighting
@@ -399,7 +407,7 @@ R_StoreWallRange
     
     // calculate rw_distance for scale calculation
     rw_normalangle = curline->angle + ANG90;
-    offsetangle = abs(rw_normalangle-rw_angle1);
+    offsetangle = abs((int)(rw_normalangle-rw_angle1)); // JWh - abs is signed!
     
     if (offsetangle > ANG90)
 	offsetangle = ANG90;
@@ -621,7 +629,7 @@ R_StoreWallRange
 	offsetangle = rw_normalangle-rw_angle1;
 	
 	if (offsetangle > ANG180)
-	    offsetangle = -offsetangle;
+	    offsetangle = 0-offsetangle; // JWh - MSVC rejects unary minus with unsigned types
 
 	if (offsetangle > ANG90)
 	    offsetangle = ANG90;
diff --git a/headless_doom/r_things.c b/headless_doom/r_things.c
index c201fff..5d9407a 100644
--- a/headless_doom/r_things.c
+++ b/headless_doom/r_things.c
@@ -216,7 +216,8 @@ void R_InitSpriteDefs (char** namelist)
 	//  filling in the frames for whatever is found
 	for (l=start+1 ; l<end ; l++)
 	{
-	    if (*(int *)lumpinfo[l].name == intname)
+	    const int* name_p = (int*) &lumpinfo[l].name; // JWh - aliasing will not matter here
+	    if (name_p[0] == intname)
 	    {
 		frame = lumpinfo[l].name[4] - 'A';
 		rotation = lumpinfo[l].name[5] - '0';
@@ -789,7 +790,7 @@ void R_SortVisSprites (void)
     int			i;
     int			count;
     vissprite_t*	ds;
-    vissprite_t*	best;
+    vissprite_t*	best = NULL; // JWh - ensure initialised
     vissprite_t		unsorted;
     fixed_t		bestscale;
 
diff --git a/headless_doom/s_sound.c b/headless_doom/s_sound.c
index bcfb538..5af70bb 100644
--- a/headless_doom/s_sound.c
+++ b/headless_doom/s_sound.c
@@ -43,6 +43,7 @@ rcsid[] = "$Id: s_sound.c,v 1.6 1997/02/03 22:45:12 b1 Exp $";
 
 #include "doomstat.h"
 
+#include "m_misc.h" // JWh - for Lump_Snprintf
 
 // Purpose?
 const char snd_prefixen[]
@@ -164,7 +165,7 @@ void S_Init
 {  
   int		i;
 
-  fprintf( stderr, "S_Init: default sfx volume %d\n", sfxVolume);
+  // fprintf( stderr, "S_Init: default sfx volume %d\n", sfxVolume); // JWh - debug to stdout only
 
   // Whatever these did with DMX, these are rather dummies now.
   I_SetChannels();
@@ -365,6 +366,7 @@ S_StartSoundAtVolume
     sfx->lumpnum = I_GetSfxLumpNum(sfx);
 
 #ifndef SNDSRV
+#ifndef HEADLESS
   // cache data if necessary
   if (!sfx->data)
   {
@@ -378,6 +380,7 @@ S_StartSoundAtVolume
     //       sfx_id, sfx->lumpnum, (int)sfx->data );
     
   }
+#endif
 #endif
   
   // increase the usefulness
@@ -651,7 +654,7 @@ S_ChangeMusic
 ( int			musicnum,
   int			looping )
 {
-    musicinfo_t*	music;
+    musicinfo_t*	music = NULL; // JWh - always initialised
     char		namebuf[9];
 
     if ( (musicnum <= mus_None)
@@ -671,7 +674,7 @@ S_ChangeMusic
     // get lumpnum if neccessary
     if (!music->lumpnum)
     {
-	sprintf(namebuf, "d_%s", music->name);
+	M_LumpSprintf(namebuf, "d_%s", music->name);
 	music->lumpnum = W_GetNumForName(namebuf);
     }
 
diff --git a/headless_doom/st_stuff.c b/headless_doom/st_stuff.c
index 16f2e3f..848c5a6 100644
--- a/headless_doom/st_stuff.c
+++ b/headless_doom/st_stuff.c
@@ -61,6 +61,8 @@ rcsid[] = "$Id: st_stuff.c,v 1.6 1997/02/03 22:45:13 b1 Exp $";
 #include "dstrings.h"
 #include "sounds.h"
 
+#include "m_misc.h" // JWh - for M_LumpSprintf
+
 //
 // STATUS BAR DATA
 //
@@ -1133,10 +1135,10 @@ void ST_loadGraphics(void)
     // Load the numbers, tall and short
     for (i=0;i<10;i++)
     {
-	sprintf(namebuf, "STTNUM%d", i);
+	M_LumpSprintf(namebuf, "STTNUM%d", i);
 	tallnum[i] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
 
-	sprintf(namebuf, "STYSNUM%d", i);
+	M_LumpSprintf(namebuf, "STYSNUM%d", i);
 	shortnum[i] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
     }
 
@@ -1147,7 +1149,7 @@ void ST_loadGraphics(void)
     // key cards
     for (i=0;i<NUMCARDS;i++)
     {
-	sprintf(namebuf, "STKEYS%d", i);
+	M_LumpSprintf(namebuf, "STKEYS%d", i);
 	keys[i] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
     }
 
@@ -1157,7 +1159,7 @@ void ST_loadGraphics(void)
     // arms ownership widgets
     for (i=0;i<6;i++)
     {
-	sprintf(namebuf, "STGNUM%d", i+2);
+	M_LumpSprintf(namebuf, "STGNUM%d", i+2);
 
 	// gray #
 	arms[i][0] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
@@ -1167,7 +1169,7 @@ void ST_loadGraphics(void)
     }
 
     // face backgrounds for different color players
-    sprintf(namebuf, "STFB%d", consoleplayer);
+    M_LumpSprintf(namebuf, "STFB%d", consoleplayer);
     faceback = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
 
     // status bar background bits
@@ -1179,18 +1181,18 @@ void ST_loadGraphics(void)
     {
 	for (j=0;j<ST_NUMSTRAIGHTFACES;j++)
 	{
-	    sprintf(namebuf, "STFST%d%d", i, j);
+	    M_LumpSprintf(namebuf, "STFST%d%d", i, j);
 	    faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
 	}
-	sprintf(namebuf, "STFTR%d0", i);	// turn right
+	M_LumpSprintf(namebuf, "STFTR%d0", i);	// turn right
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
-	sprintf(namebuf, "STFTL%d0", i);	// turn left
+	M_LumpSprintf(namebuf, "STFTL%d0", i);	// turn left
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
-	sprintf(namebuf, "STFOUCH%d", i);	// ouch!
+	M_LumpSprintf(namebuf, "STFOUCH%d", i);	// ouch!
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
-	sprintf(namebuf, "STFEVL%d", i);	// evil grin ;)
+	M_LumpSprintf(namebuf, "STFEVL%d", i);	// evil grin ;)
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
-	sprintf(namebuf, "STFKILL%d", i);	// pissed off
+	M_LumpSprintf(namebuf, "STFKILL%d", i);	// pissed off
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
     }
     faces[facenum++] = W_CacheLumpName("STFGOD0", PU_STATIC);
diff --git a/headless_doom/timing.c b/headless_doom/timing.c
new file mode 100644
index 0000000..88fb8ef
--- /dev/null
+++ b/headless_doom/timing.c
@@ -0,0 +1,35 @@
+
+#include "headless.h"
+
+#ifdef _MSC_VER
+#include <Windows.h>
+uint64_t M_GetTimeMicroseconds() {
+    SYSTEMTIME st;
+    FILETIME ft;
+    uint64_t time;
+    // get time in hour:minute:second form
+    GetSystemTime(&st);
+    // convert to a count of 100 nanosecond intervals since some epoch
+    SystemTimeToFileTime(&st, &ft);
+    // store in a single 64-bit value
+    time = ((uint64_t) ft.dwLowDateTime);
+    time += ((uint64_t) ft.dwHighDateTime) << 32;
+    // convert to microseconds
+    return time / 10;
+}
+#else
+#include <sys/time.h>
+#include <stddef.h>
+uint64_t M_GetTimeMicroseconds() {
+    struct timeval st;
+    uint64_t time;
+    // get time in microseconds
+    gettimeofday(&st, NULL);
+    // store in a single 64-bit value
+    time = ((uint64_t)st.tv_sec) * 1000000;
+    time += (uint64_t)st.tv_usec;
+    // convert to microseconds
+    return time;
+}
+#endif
+
diff --git a/headless_doom/w_wad.c b/headless_doom/w_wad.c
index 178f5cb..f38801a 100644
--- a/headless_doom/w_wad.c
+++ b/headless_doom/w_wad.c
@@ -38,6 +38,12 @@ rcsid[] = "$Id: w_wad.c,v 1.5 1997/02/03 16:47:57 b1 Exp $";
 #define O_BINARY		0
 #endif
 
+#include <ctype.h> // JWh - for 'toupper'
+#include <string.h> // JWh - for 'strlen'
+#ifdef HEADLESS
+#include "headless.h" // for alloca
+#endif
+
 #include "doomtype.h"
 #include "m_swap.h"
 #include "i_system.h"
@@ -66,19 +72,19 @@ void**			lumpcache;
 
 #define strcmpi	strcasecmp
 
-void strupr (char* s)
+void my_strupr (char* s) // JWh - strupr is not always available in the C library
 {
     while (*s) { *s = toupper(*s); s++; }
 }
 
-int filelength (int handle) 
+int filelength (FILE* handle)  // JWh - use stdio file functions
 { 
-    struct stat	fileinfo;
+    int size;
     
-    if (fstat (handle,&fileinfo) == -1)
-	I_Error ("Error fstating");
-
-    return fileinfo.st_size;
+    fseek (handle, 0, SEEK_END);
+    size = (int) ftell (handle);
+    fseek (handle, 0, SEEK_SET);
+    return size;
 }
 
 
@@ -143,12 +149,12 @@ void W_AddFile (char *filename)
     wadinfo_t		header;
     lumpinfo_t*		lump_p;
     unsigned		i;
-    int			handle;
+    FILE*	handle;
     int			length;
     int			startlump;
     filelump_t*		fileinfo;
     filelump_t		singleinfo;
-    int			storehandle;
+    FILE*	storehandle;
     
     // open the file and add to directory
 
@@ -160,7 +166,7 @@ void W_AddFile (char *filename)
 	reloadlump = numlumps;
     }
 		
-    if ( (handle = open (filename,O_RDONLY | O_BINARY)) == -1)
+    if ( (handle = fopen (filename, "rb")) == NULL) // JWh - use stdio file functions
     {
 	printf (" couldn't open %s\n",filename);
 	return;
@@ -181,7 +187,7 @@ void W_AddFile (char *filename)
     else 
     {
 	// WAD file
-	read (handle, &header, sizeof(header));
+	fread (&header, 1, sizeof(header), handle); // JWh - use stdio file functions
 	if (strncmp(header.identification,"IWAD",4))
 	{
 	    // Homebrew levels?
@@ -197,8 +203,8 @@ void W_AddFile (char *filename)
 	header.infotableofs = LONG(header.infotableofs);
 	length = header.numlumps*sizeof(filelump_t);
 	fileinfo = alloca (length);
-	lseek (handle, header.infotableofs, SEEK_SET);
-	read (handle, fileinfo, length);
+	fseek (handle, header.infotableofs, SEEK_SET); // JWh - use stdio file functions
+	fread (fileinfo, 1, length, handle);           // JWh - use stdio file functions
 	numlumps += header.numlumps;
     }
 
@@ -211,7 +217,7 @@ void W_AddFile (char *filename)
 
     lump_p = &lumpinfo[startlump];
 	
-    storehandle = reloadname ? -1 : handle;
+    storehandle = reloadname ? NULL : handle; // JWh - use stdio file functions
 	
     for (i=startlump ; i<numlumps ; i++,lump_p++, fileinfo++)
     {
@@ -222,7 +228,7 @@ void W_AddFile (char *filename)
     }
 	
     if (reloadname)
-	close (handle);
+	fclose (handle);
 }
 
 
@@ -239,23 +245,23 @@ void W_Reload (void)
     int			lumpcount;
     lumpinfo_t*		lump_p;
     unsigned		i;
-    int			handle;
+    FILE*	handle;
     int			length;
     filelump_t*		fileinfo;
 	
     if (!reloadname)
 	return;
 		
-    if ( (handle = open (reloadname,O_RDONLY | O_BINARY)) == -1)
+    if ( (handle = fopen (reloadname, "rb")) == NULL) // JWh - use stdio file functions
 	I_Error ("W_Reload: couldn't open %s",reloadname);
 
-    read (handle, &header, sizeof(header));
+    fread (&header, 1, sizeof(header), handle);
     lumpcount = LONG(header.numlumps);
     header.infotableofs = LONG(header.infotableofs);
     length = lumpcount*sizeof(filelump_t);
     fileinfo = alloca (length);
-    lseek (handle, header.infotableofs, SEEK_SET);
-    read (handle, fileinfo, length);
+    fseek (handle, header.infotableofs, SEEK_SET);
+    fread (fileinfo, 1, length, handle);
     
     // Fill in lumpinfo
     lump_p = &lumpinfo[reloadlump];
@@ -271,7 +277,7 @@ void W_Reload (void)
 	lump_p->size = LONG(fileinfo->size);
     }
 	
-    close (handle);
+    fclose (handle);
 }
 
 
@@ -367,7 +373,7 @@ int W_CheckNumForName (char* name)
     name8.s[8] = 0;
 
     // case insensitive
-    strupr (name8.s);		
+    my_strupr (name8.s);		// JWh - strupr not always available
 
     v1 = name8.x[0];
     v2 = name8.x[1];
@@ -378,8 +384,8 @@ int W_CheckNumForName (char* name)
 
     while (lump_p-- != lumpinfo)
     {
-	if ( *(int *)lump_p->name == v1
-	     && *(int *)&lump_p->name[4] == v2)
+	const int* name_p = (int*) lump_p->name; // JWh - aliasing will not matter here
+	if (name_p[0] == v1 && name_p[1] == v2)
 	{
 	    return lump_p - lumpinfo;
 	}
@@ -435,7 +441,7 @@ W_ReadLump
 {
     int		c;
     lumpinfo_t*	l;
-    int		handle;
+    FILE* handle;
 	
     if (lump >= numlumps)
 	I_Error ("W_ReadLump: %i >= numlumps",lump);
@@ -444,24 +450,24 @@ W_ReadLump
 	
     // ??? I_BeginRead ();
 	
-    if (l->handle == -1)
+    if (l->handle == NULL)
     {
 	// reloadable file, so use open / read / close
-	if ( (handle = open (reloadname,O_RDONLY | O_BINARY)) == -1)
+	if ( (handle = fopen (reloadname, "rb")) == NULL) // JWh - use stdio file functions
 	    I_Error ("W_ReadLump: couldn't open %s",reloadname);
     }
     else
 	handle = l->handle;
 		
-    lseek (handle, l->position, SEEK_SET);
-    c = read (handle, dest, l->size);
+    fseek (handle, l->position, SEEK_SET);
+    c = fread (dest, 1, l->size, handle);
 
     if (c < l->size)
 	I_Error ("W_ReadLump: only read %i of %i on lump %i",
 		 c,l->size,lump);	
 
-    if (l->handle == -1)
-	close (handle);
+    if (l->handle == NULL)
+	fclose (handle);
 		
     // ??? I_EndRead ();
 }
diff --git a/headless_doom/w_wad.h b/headless_doom/w_wad.h
index db1faaa..fd496a6 100644
--- a/headless_doom/w_wad.h
+++ b/headless_doom/w_wad.h
@@ -56,7 +56,7 @@ typedef struct
 typedef struct
 {
     char	name[8];
-    int		handle;
+    FILE*   handle;
     int		position;
     int		size;
 } lumpinfo_t;
diff --git a/headless_doom/wi_stuff.c b/headless_doom/wi_stuff.c
index 01502c8..90f6c9d 100644
--- a/headless_doom/wi_stuff.c
+++ b/headless_doom/wi_stuff.c
@@ -42,6 +42,8 @@ rcsid[] = "$Id: wi_stuff.c,v 1.7 1997/02/03 22:45:13 b1 Exp $";
 
 #include "doomstat.h"
 
+#include "m_misc.h" // JWh - for M_LumpSprintf
+
 // Data.
 #include "sounds.h"
 
@@ -1545,7 +1547,7 @@ void WI_loadData(void)
     if (gamemode == commercial)
 	strcpy(name, "INTERPIC");
     else 
-	sprintf(name, "WIMAP%d", wbs->epsd);
+	M_LumpSprintf(name, "WIMAP%d", wbs->epsd);
     
     if ( gamemode == retail )
     {
@@ -1576,7 +1578,7 @@ void WI_loadData(void)
 				       PU_STATIC, 0);
 	for (i=0 ; i<NUMCMAPS ; i++)
 	{								
-	    sprintf(name, "CWILV%2.2d", i);
+	    M_LumpSprintf(name, "CWILV%2.2d", i);
 	    lnames[i] = W_CacheLumpName(name, PU_STATIC);
 	}					
     }
@@ -1586,7 +1588,7 @@ void WI_loadData(void)
 				       PU_STATIC, 0);
 	for (i=0 ; i<NUMMAPS ; i++)
 	{
-	    sprintf(name, "WILV%d%d", wbs->epsd, i);
+	    M_LumpSprintf(name, "WILV%d%d", wbs->epsd, i);
 	    lnames[i] = W_CacheLumpName(name, PU_STATIC);
 	}
 
@@ -1610,7 +1612,7 @@ void WI_loadData(void)
 		    if (wbs->epsd != 1 || j != 8) 
 		    {
 			// animations
-			sprintf(name, "WIA%d%.2d%.2d", wbs->epsd, j, i);  
+			M_LumpSprintf(name, "WIA%d%.2d%.2d", wbs->epsd, j, i);  
 			a->p[i] = W_CacheLumpName(name, PU_STATIC);
 		    }
 		    else
@@ -1629,7 +1631,7 @@ void WI_loadData(void)
     for (i=0;i<10;i++)
     {
 	 // numbers 0-9
-	sprintf(name, "WINUM%d", i);     
+	M_LumpSprintf(name, "WINUM%d", i);     
 	num[i] = W_CacheLumpName(name, PU_STATIC);
     }
 
@@ -1695,11 +1697,11 @@ void WI_loadData(void)
     for (i=0 ; i<MAXPLAYERS ; i++)
     {
 	// "1,2,3,4"
-	sprintf(name, "STPB%d", i);      
+	M_LumpSprintf(name, "STPB%d", i);      
 	p[i] = W_CacheLumpName(name, PU_STATIC);
 
 	// "1,2,3,4"
-	sprintf(name, "WIBP%d", i+1);     
+	M_LumpSprintf(name, "WIBP%d", i+1);     
 	bp[i] = W_CacheLumpName(name, PU_STATIC);
     }
 
diff --git a/headless_doom/z_zone.c b/headless_doom/z_zone.c
index 4345485..4c17808 100644
--- a/headless_doom/z_zone.c
+++ b/headless_doom/z_zone.c
@@ -192,7 +192,7 @@ Z_Malloc
     memblock_t* newblock;
     memblock_t*	base;
 
-    size = (size + 3) & ~3;
+    size = (size + sizeof(void*) - 1) & ~(sizeof(void*) - 1); // JWh - 64-bit compatibility
     
     // scan through the block list,
     // looking for the first free block
@@ -437,7 +437,7 @@ Z_ChangeTag2
     if (block->id != ZONEID)
 	I_Error ("Z_ChangeTag: freed a pointer without ZONEID");
 
-    if (tag >= PU_PURGELEVEL && (unsigned)block->user < 0x100)
+    if (tag >= PU_PURGELEVEL && (unsigned)((intptr_t)block->user) < 0x100) // JWh - 64-bit compat
 	I_Error ("Z_ChangeTag: an owner is required for purgable blocks");
 
     block->tag = tag;
diff --git a/pic.png b/pic.png
new file mode 100644
index 0000000..133acf0
Binary files /dev/null and b/pic.png differ
