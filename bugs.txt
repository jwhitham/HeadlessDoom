
Classification of Doom source code bugs


# DSB-1 - missing explicit integer types

In some C compilers, you can write `static x` or `register x`
and `int` is implicit. For example:

     static nexttic = 0;

# DSB-2 - ambiguous assignment with post/pre-increment

A single statement combines two assignments, e.g.

     eventhead = (++eventhead)&(MAXEVENTS-1);

# DSB-3 - assumption that pointers are 32-bit

Generally, this takes the form of casting pointers to/from integers,
but in some places a size of 4 bytes is explicitly used when calculating
memory sizes.

    statcopy = (void*)atoi(myargv[p+1]);
    return (int)&(((doomdata_t *)0)->cmds[netbuffer->numtics]); 

# DSB-4 - assumption that char is signed

On x86, `char` is conventionally a signed type, but the C standard
does not specify this, and on other platforms, e.g. ARM, it is unsigned.

    char	forwardmove;	// *2048 for move

# DSB-5 - Headless Doom should play demos rather than an interactive game

`D_DoAdvanceDemo` and `IdentifyVersion` are replaced by functions
in the `headless.c` test harness file, so that Doom is driven through
the DDQ demo files without any user interaction. This feature is
activated when `HEADLESS` is defined.

# DSB-6 - replace system-specific defines and header files

Linux Doom used various system-specific headers such as `unistd.h`
and defines such as `NORMALUNIX` and `LINUX`. These appeared in many
source files. 

They are removed, and often replaced by including
`headless.h` if `HEADLESS` is defined.

Aside from bug fixes, the source code will compile in the same way as
vanilla Linux Doom if `-DNORMALUNIX -DLINUX` are used in `CFLAGS`
without `-DHEADLESS`.

# DSB-7 - log messages for the start of a new demo or a new level

Headless Doom logs these important events using modifications in
`g_game.c`.

# DSB-8 - GameMission_t / GameMode_t mixup

Tests of `gamemode` wrongly used enumeration values from
`GameMission_t`, causing compilation errors. The original
behaviour is preserved.

# DSB-9 - incorrect memset bounds in G_DoLoadLevel

`memset` functions in `G_DoLoadLevel` should clear all
of the provided memory area, but instead they clear
only a small part (often the size of a pointer). For example:

    memset (players[i].frags,0,sizeof(players[i].frags)); 

The correct size is provided.

# DSB-10 - pointer targets differ in signedness

Both `strcmp` parameters are `char *`, but `unsigned char`
was used instead. Example:

    if (strcmp (save_p, vcheck)) 

Resolved by a type cast.

# DSB-11 - system-specific networking, sound and video code

Headless Doom is not interactive and does not use any network,
video or sound, so the whole contents of `i_net.c`
`i_video.c` and `i_sound.c` are removed by `#ifndef HEADLESS`.
Functions in these files are replaced in `headless.c`,
mostly with empty stubs.

# DSB-12 - potentially non-deterministic code

Code that accesses a timer or real-time clock is non-deterministic
and will affect the benchmark's operation in various ways. Settings
the `singletics` flag will lead to correct demo playback (as in
vanilla Linux Doom) but won't control all effects. For example,
the screen wipe effect as a new level is loaded is also dependent on
a timer. Therefore, in Headless Doom, calls relating to timing
are replaced by stubs.

Similarly, code that accesses configuration files, saved games
and command-line parameters is replaced by stubs. These inputs
could affect benchmark operation. Configuration file defaults are
replaced by constant values where necessary.

# DSB-13 - NULL sentinel required for sprnames table

The `sprnames` table in `info.c` has a fixed size (`NUMSPRITES`)
but this size is not used by `R_InitSpriteDefs` when reading the
table. Instead, `R_InitSpriteDefs` looks for a NULL value at the
end. This isn't always present, as the C code does not specify it,
and it may just be a matter of chance whether the bytes following
`sprnames` are NULL or not.

# DSB-14 - Prevent potential sprintf overflows for WAD file lump names

`sprintf` is not given a maximum buffer size. Because of the potential
risk of buffer overflow, some C compilers now analyse `sprintf` calls
to determine if memory beyond the end of the buffer might be
overwritten. This can include analysis of the maximum size of
integers and strings that are substituted, e.g. with `%i` or `%s`.

This affects Doom in many places, mostly relating to finding resources
within the WAD file, as each resource has an 1..8-byte key. When
these keys are generated using `sprintf`, the compiler may attempt to
check that more than 9 bytes will not be written (as `sprintf` also
writes a terminating nul byte). Due to a lack of information about the
true bounds of variables, the compiler must pessimistically overestimate
the possible size of string: for example, `"map%i"` would overflow if
there were more than 99999 maps. To deal with these problems in one place,
`M_LumpSprintf` has been added to `m_misc.c` as a replacement for
`sprintf` which is intended specifically for WAD file keys.

# DSB-15 - Prevent potential sprintf overflows aside from WAD file lump names

`sprintf` is also used in other places without correct bounding.
For example, the names of save games, printed by the Quick Load feature,
might overflow the buffer.

    char    tempstring[80];
    sprintf(tempstring,QSPROMPT,savegamestrings[quickSaveSlot]);

Calls to `snprintf` are used instead, with an explicit buffer size.




@@ -59,6 +61,8 @@ rcsid[] = "$Id: m_misc.c,v 1.6 1997/02/03 22:45:10 b1 Exp $";
 
 #include "m_misc.h"
 
+#include "headless.h" // JWh - definition of access, M_LumpSprintf
+
 //
 // M_DrawText
 // Returns the final X coordinate
@@ -105,26 +109,22 @@ M_DrawText
 //
 // M_WriteFile
 //
-#ifndef O_BINARY
-#define O_BINARY 0
-#endif
-
 boolean
 M_WriteFile
 ( char const*	name,
   void*		source,
   int		length )
 {
-    int		handle;
+    FILE* handle;
     int		count;
 	
-    handle = open ( name, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666);
+    handle = fopen ( name, "wb" );
 
-    if (handle == -1)
+    if (handle == NULL)
 	return false;
 
-    count = write (handle, source, length);
-    close (handle);
+    count = fwrite (source, 1, length, handle);
+    fclose (handle);
 	
     if (count < length)
 	return false;
@@ -141,6 +141,8 @@ M_ReadFile
 ( char const*	name,
   byte**	buffer )
 {
+#ifndef HEADLESS
+    /* Not used in Headless Doom */
     int	handle, count, length;
     struct stat	fileinfo;
     byte		*buf;
@@ -160,9 +162,14 @@ M_ReadFile
 		
     *buffer = buf;
     return length;
+#else
+    *buffer = NULL;
+#endif
+    return 0;
 }
 
 
+
 //
 // DEFAULTS
 //
@@ -221,6 +228,7 @@ char*		mousedev;
 extern char*	chat_macros[];
 
 
+#ifndef HEADLESS
 
 typedef struct
 {
@@ -402,6 +410,7 @@ void M_LoadDefaults (void)
     }
 }
 
+#endif
 
 //
 // SCREEN SHOTS
@@ -531,4 +540,18 @@ void M_ScreenShot (void)
     players[consoleplayer].message = "screen shot";
 }
 
+// JWh - This version of sprintf writes at most 9 bytes and is specifically
+// intended for formatting the lump names that appear within the WAD file.
+// There may be up to 8 characters. The 9th byte is always '\0'.
+int M_LumpSprintf (char *lumpname, const char *format, ...)
+{
+    va_list	argptr;
+    int count;
+
+    va_start (argptr, format);
+    count = vsnprintf (lumpname, 9, format, argptr);
+    va_end (argptr);
+    return count;
+}
+
 
diff --git a/headless_doom/m_misc.h b/headless_doom/m_misc.h
index 82afb0f..937d682 100644
--- a/headless_doom/m_misc.h
+++ b/headless_doom/m_misc.h
@@ -57,6 +57,11 @@ M_DrawText
   char*		string );
 
 
+// JWh - This version of sprintf writes at most 9 bytes and is specifically
+// intended for formatting the lump names that appear within the WAD file.
+// There may be up to 8 characters. The 9th byte is always '\0'.
+int M_LumpSprintf(char *lumpname, const char *format, ...);
+
 #endif
 //-----------------------------------------------------------------------------
 //
diff --git a/headless_doom/p_doors.c b/headless_doom/p_doors.c
index b22dd15..fc23a1d 100644
--- a/headless_doom/p_doors.c
+++ b/headless_doom/p_doors.c
@@ -184,7 +184,7 @@ void T_VerticalDoor (vldoor_t* door)
 		
 	      case close30ThenOpen:
 	      case blazeOpen:
-	      case open:
+	      case dopen: // JWh - renamed
 		door->sector->specialdata = NULL;
 		P_RemoveThinker (&door->thinker);  // unlink and free
 		break;
@@ -329,7 +329,7 @@ EV_DoDoor
 	    break;
 	    
 	  case normal:
-	  case open:
+	  case dopen: // JWh - renamed
 	    door->direction = 1;
 	    door->topheight = P_FindLowestCeilingSurrounding(sec);
 	    door->topheight -= 4*FRACUNIT;
@@ -478,7 +478,7 @@ EV_VerticalDoor
       case 32:
       case 33:
       case 34:
-	door->type = open;
+	door->type = dopen; // JWh - renamed
 	line->special = 0;
 	break;
 	
diff --git a/headless_doom/p_enemy.c b/headless_doom/p_enemy.c
index 25b5b2d..298d604 100644
--- a/headless_doom/p_enemy.c
+++ b/headless_doom/p_enemy.c
@@ -589,7 +589,7 @@ void A_KeenDie (mobj_t* mo)
     }
 
     junk.tag = 666;
-    EV_DoDoor(&junk,open);
+    EV_DoDoor(&junk,dopen); // JWh - renamed
 }
 
 
diff --git a/headless_doom/p_floor.c b/headless_doom/p_floor.c
index 37a6cd8..9541112 100644
--- a/headless_doom/p_floor.c
+++ b/headless_doom/p_floor.c
@@ -467,8 +467,8 @@ EV_BuildStairs
 
     floormove_t*	floor;
     
-    fixed_t		stairsize;
-    fixed_t		speed;
+    fixed_t		stairsize = 0; // JWh - if 'type' is invalid, this will be undefined
+    fixed_t		speed = 0;     // JWh - if 'type' is invalid, this will be undefined
 
     secnum = -1;
     rtn = 0;
diff --git a/headless_doom/p_maputl.c b/headless_doom/p_maputl.c
index 597b19c..ace764c 100644
--- a/headless_doom/p_maputl.c
+++ b/headless_doom/p_maputl.c
@@ -111,8 +111,8 @@ P_BoxOnLineSide
 ( fixed_t*	tmbox,
   line_t*	ld )
 {
-    int		p1;
-    int		p2;
+    int		p1 = 0; // JWh - initialise variable in case ld->slopetype is invalid
+    int		p2 = 0; // JWh - initialise variable in case ld->slopetype is invalid
 	
     switch (ld->slopetype)
     {
diff --git a/headless_doom/p_saveg.c b/headless_doom/p_saveg.c
index 4500a54..c3342f5 100644
--- a/headless_doom/p_saveg.c
+++ b/headless_doom/p_saveg.c
@@ -21,6 +21,8 @@
 //
 //-----------------------------------------------------------------------------
 
+#ifndef HEADLESS
+
 static const char
 rcsid[] = "$Id: p_tick.c,v 1.4 1997/02/03 16:47:55 b1 Exp $";
 
@@ -583,4 +585,5 @@ void P_UnArchiveSpecials (void)
     }
 
 }
+#endif
 
diff --git a/headless_doom/p_setup.c b/headless_doom/p_setup.c
index e5d3667..a824c0f 100644
--- a/headless_doom/p_setup.c
+++ b/headless_doom/p_setup.c
@@ -43,6 +43,7 @@ rcsid[] = "$Id: p_setup.c,v 1.5 1997/02/03 22:45:12 b1 Exp $";
 
 #include "s_sound.h"
 
+#include "m_misc.h" // JWh - for M_LumpSprintf
 #include "doomstat.h"
 
 
@@ -533,7 +534,7 @@ void P_GroupLines (void)
     }
 	
     // build line tables for each sector	
-    linebuffer = Z_Malloc (total*4, PU_LEVEL, 0);
+    linebuffer = Z_Malloc (total*sizeof(void*), PU_LEVEL, 0); // JWh - 64-bit compat
     sector = sectors;
     for (i=0 ; i<numsectors ; i++, sector++)
     {
@@ -628,9 +629,9 @@ P_SetupLevel
     if ( gamemode == commercial)
     {
 	if (map<10)
-	    sprintf (lumpname,"map0%i", map);
+	    M_LumpSprintf (lumpname,"map0%i", map);  // JWh - use bounded format
 	else
-	    sprintf (lumpname,"map%i", map);
+	    M_LumpSprintf (lumpname,"map%i", map);   // JWh - use bounded format
     }
     else
     {
diff --git a/headless_doom/p_spec.c b/headless_doom/p_spec.c
index f048afb..b5cdd29 100644
--- a/headless_doom/p_spec.c
+++ b/headless_doom/p_spec.c
@@ -72,7 +72,7 @@ typedef struct
 //
 typedef struct
 {
-    boolean	istexture;	// if false, it is a flat
+    signed char istexture;	// if false, it is a flat // JWh - use explicit signed type
     char	endname[9];
     char	startname[9];
     int		speed;
@@ -542,7 +542,7 @@ P_CrossSpecialLine
 	// All from here to RETRIGGERS.
       case 2:
 	// Open Door
-	EV_DoDoor(line,open);
+	EV_DoDoor(line,dopen); // JWh - renamed
 	line->special = 0;
 	break;
 
@@ -846,7 +846,7 @@ P_CrossSpecialLine
 
       case 86:
 	// Open Door
-	EV_DoDoor(line,open);
+	EV_DoDoor(line,dopen); // JWh - renamed
 	break;
 	
       case 87:
@@ -987,7 +987,7 @@ P_ShootSpecialLine
 	
       case 46:
 	// OPEN DOOR
-	EV_DoDoor(line,open);
+	EV_DoDoor(line,dopen); // JWh - renamed
 	P_ChangeSwitchTexture(line,1);
 	break;
 	
@@ -1184,7 +1184,7 @@ int EV_DoDonut(line_t*	line)
 	s2 = getNextSector(s1->lines[0],s1);
 	for (i = 0;i < s2->linecount;i++)
 	{
-	    if ((!s2->lines[i]->flags & ML_TWOSIDED) ||
+	    if ((!(s2->lines[i]->flags & ML_TWOSIDED)) || // JWh - brackets added
 		(s2->lines[i]->backsector == s1))
 		continue;
 	    s3 = s2->lines[i]->backsector;
diff --git a/headless_doom/p_spec.h b/headless_doom/p_spec.h
index 39155bf..7a66b68 100644
--- a/headless_doom/p_spec.h
+++ b/headless_doom/p_spec.h
@@ -321,7 +321,6 @@ void    P_RemoveActivePlat(plat_t* plat);
 void    EV_StopPlat(line_t* line);
 void    P_ActivateInStasis(int tag);
 
-
 //
 // P_DOORS
 //
@@ -330,7 +329,7 @@ typedef enum
     normal,
     close30ThenOpen,
     close,
-    open,
+    dopen, // JWh - termux stdio.h defines 'open', causing a clash.
     raiseIn5Mins,
     blazeRaise,
     blazeOpen,
diff --git a/headless_doom/p_switch.c b/headless_doom/p_switch.c
index 5880732..dcc80b0 100644
--- a/headless_doom/p_switch.c
+++ b/headless_doom/p_switch.c
@@ -454,7 +454,7 @@ P_UseSpecialLine
 	
       case 103:
 	// Open Door
-	if (EV_DoDoor(line,open))
+	if (EV_DoDoor(line,dopen)) // JWh - renamed
 	    P_ChangeSwitchTexture(line,0);
 	break;
 	
@@ -537,7 +537,7 @@ P_UseSpecialLine
 	
       case 61:
 	// Open Door
-	if (EV_DoDoor(line,open))
+	if (EV_DoDoor(line,dopen)) // JWh - renamed
 	    P_ChangeSwitchTexture(line,1);
 	break;
 	
diff --git a/headless_doom/r_bsp.c b/headless_doom/r_bsp.c
index adc9f75..9da0749 100644
--- a/headless_doom/r_bsp.c
+++ b/headless_doom/r_bsp.c
@@ -303,7 +303,7 @@ void R_AddLine (seg_t*	line)
 	// Totally off the left edge?
 	if (tspan >= span)
 	    return;	
-	angle2 = -clipangle;
+	angle2 = 0-clipangle; // JWh - MSVC rejects unary minus with unsigned types
     }
     
     // The seg is in the view range,
@@ -455,7 +455,7 @@ boolean R_CheckBBox (fixed_t*	bspcoord)
 	if (tspan >= span)
 	    return false;
 	
-	angle2 = -clipangle;
+	angle2 = 0-clipangle; // JWh - MSVC rejects unary minus with unsigned types
     }
 
 
diff --git a/headless_doom/r_data.c b/headless_doom/r_data.c
index acabd53..73763ec 100644
--- a/headless_doom/r_data.c
+++ b/headless_doom/r_data.c
@@ -45,6 +45,10 @@ rcsid[] = "$Id: r_data.c,v 1.4 1997/02/03 16:47:55 b1 Exp $";
 #include  <alloca.h>
 #endif
 
+#ifdef HEADLESS
+#include "headless.h"   // JWh - for alloca
+#endif
+
 
 #include "r_data.h"
 
@@ -87,7 +91,7 @@ typedef struct
     boolean		masked;	
     short		width;
     short		height;
-    void		**columndirectory;	// OBSOLETE
+    int		columndirectory;	// OBSOLETE // JWh - 64-bit compat, use 4 bytes
     short		patchcount;
     mappatch_t	patches[1];
 } maptexture_t;
@@ -241,9 +245,10 @@ void R_GenerateComposite (int texnum)
 	
     texture = textures[texnum];
 
-    block = Z_Malloc (texturecompositesize[texnum],
-		      PU_STATIC, 
-		      &texturecomposite[texnum]);	
+    block = Z_Malloc (texturecompositesize[texnum] + 1, // JWh - allocate 1 extra byte which may be drawn
+		      PU_STATIC,                                // in some circumstances. Issue first seen in E1M2,
+		      &texturecomposite[texnum]);	            // at headless_count 902 x 276 y 109. Zero this byte.
+    block[texturecompositesize[texnum]] = 0;
 
     collump = texturecolumnlump[texnum];
     colofs = texturecolumnofs[texnum];
@@ -479,13 +484,13 @@ void R_InitTextures (void)
     }
     numtextures = numtextures1 + numtextures2;
 	
-    textures = Z_Malloc (numtextures*4, PU_STATIC, 0);
-    texturecolumnlump = Z_Malloc (numtextures*4, PU_STATIC, 0);
-    texturecolumnofs = Z_Malloc (numtextures*4, PU_STATIC, 0);
-    texturecomposite = Z_Malloc (numtextures*4, PU_STATIC, 0);
-    texturecompositesize = Z_Malloc (numtextures*4, PU_STATIC, 0);
-    texturewidthmask = Z_Malloc (numtextures*4, PU_STATIC, 0);
-    textureheight = Z_Malloc (numtextures*4, PU_STATIC, 0);
+    textures = Z_Malloc (numtextures*sizeof(void*), PU_STATIC, 0); // JWh - 64-bit compat
+    texturecolumnlump = Z_Malloc (numtextures*sizeof(void*), PU_STATIC, 0);
+    texturecolumnofs = Z_Malloc (numtextures*sizeof(void*), PU_STATIC, 0);
+    texturecomposite = Z_Malloc (numtextures*sizeof(void*), PU_STATIC, 0);
+    texturecompositesize = Z_Malloc (numtextures*sizeof(void*), PU_STATIC, 0);
+    texturewidthmask = Z_Malloc (numtextures*sizeof(void*), PU_STATIC, 0);
+    textureheight = Z_Malloc (numtextures*sizeof(void*), PU_STATIC, 0);
 
     totalwidth = 0;
     
@@ -567,7 +572,7 @@ void R_InitTextures (void)
 	R_GenerateLookup (i);
     
     // Create translation table for global animation.
-    texturetranslation = Z_Malloc ((numtextures+1)*4, PU_STATIC, 0);
+    texturetranslation = Z_Malloc ((numtextures+1)*sizeof(void*), PU_STATIC, 0); // JWh - 64-bit compat
     
     for (i=0 ; i<numtextures ; i++)
 	texturetranslation[i] = i;
@@ -587,7 +592,7 @@ void R_InitFlats (void)
     numflats = lastflat - firstflat + 1;
 	
     // Create translation table for global animation.
-    flattranslation = Z_Malloc ((numflats+1)*4, PU_STATIC, 0);
+    flattranslation = Z_Malloc ((numflats+1)*sizeof(void*), PU_STATIC, 0); // JWh - 64-bit compat
     
     for (i=0 ; i<numflats ; i++)
 	flattranslation[i] = i;
@@ -609,9 +614,9 @@ void R_InitSpriteLumps (void)
     lastspritelump = W_GetNumForName ("S_END") - 1;
     
     numspritelumps = lastspritelump - firstspritelump + 1;
-    spritewidth = Z_Malloc (numspritelumps*4, PU_STATIC, 0);
-    spriteoffset = Z_Malloc (numspritelumps*4, PU_STATIC, 0);
-    spritetopoffset = Z_Malloc (numspritelumps*4, PU_STATIC, 0);
+    spritewidth = Z_Malloc (numspritelumps*sizeof(void*), PU_STATIC, 0); // JWh - 64-bit compat
+    spriteoffset = Z_Malloc (numspritelumps*sizeof(void*), PU_STATIC, 0);
+    spritetopoffset = Z_Malloc (numspritelumps*sizeof(void*), PU_STATIC, 0);
 	
     for (i=0 ; i< numspritelumps ; i++)
     {
@@ -639,7 +644,7 @@ void R_InitColormaps (void)
     lump = W_GetNumForName("COLORMAP"); 
     length = W_LumpLength (lump) + 255; 
     colormaps = Z_Malloc (length, PU_STATIC, 0); 
-    colormaps = (byte *)( ((int)colormaps + 255)&~0xff); 
+    colormaps = (byte *)( ((intptr_t)colormaps + 255)&~0xff);  // JWh - 64-bit compatibility
     W_ReadLump (lump,colormaps); 
 }
 
diff --git a/headless_doom/r_draw.c b/headless_doom/r_draw.c
index 0145044..d36a977 100644
--- a/headless_doom/r_draw.c
+++ b/headless_doom/r_draw.c
@@ -132,6 +132,17 @@ void R_DrawColumn (void)
     fracstep = dc_iscale; 
     frac = dc_texturemid + (dc_yl-centery)*fracstep; 
 
+    // JWh: If the position is before the start of the column, fill
+    // with black to avoid accessing undefined memory (before dc_source).
+    // Issue first seen in E1M1 at headless_count 191 x 149 y 85.
+    while (frac < 0) {
+        *dest = 0;
+        dest += SCREENWIDTH;
+        frac += fracstep;
+        count --;
+        if (count < 0) return;
+    }
+
     // Inner loop that does the actual texture mapping,
     //  e.g. a DDA-lile scaling.
     // This is as fast as it gets.
@@ -461,7 +472,7 @@ void R_InitTranslationTables (void)
     int		i;
 	
     translationtables = Z_Malloc (256*3+255, PU_STATIC, 0);
-    translationtables = (byte *)(( (int)translationtables + 255 )& ~255);
+    translationtables = (byte *)(( (intptr_t)translationtables + 255 )& ~255); // JWh - 64-bit compat
     
     // translate just the 16 green colors
     for (i=0 ; i<256 ; i++)
diff --git a/headless_doom/r_main.c b/headless_doom/r_main.c
index ad942c7..d7f1339 100644
--- a/headless_doom/r_main.c
+++ b/headless_doom/r_main.c
@@ -325,7 +325,7 @@ R_PointToAngle
 	    if (x>y)
 	    {
 		// octant 8
-		return -tantoangle[SlopeDiv(y,x)];
+		return 0-tantoangle[SlopeDiv(y,x)]; // JWh - MSVC rejects unary minus with unsigned types
 	    }
 	    else
 	    {
@@ -453,8 +453,9 @@ void R_InitPointToAngle (void)
 fixed_t R_ScaleFromGlobalAngle (angle_t visangle)
 {
     fixed_t		scale;
-    int			anglea;
-    int			angleb;
+    unsigned anglea; // JWh - need to use logical right shift for finesine
+    unsigned angleb; // lookup, otherwise array index is negative. Issue
+                     // first seen in E1M2 headless_count 1098 x 61 y 66
     int			sinea;
     int			sineb;
     fixed_t		num;
diff --git a/headless_doom/r_segs.c b/headless_doom/r_segs.c
index 1962d92..28b1582 100644
--- a/headless_doom/r_segs.c
+++ b/headless_doom/r_segs.c
@@ -210,7 +210,7 @@ void R_RenderSegLoop (void)
     int			yl;
     int			yh;
     int			mid;
-    fixed_t		texturecolumn;
+    fixed_t		texturecolumn = 0; // JWh - ensure initialised
     int			top;
     int			bottom;
 
@@ -263,6 +263,14 @@ void R_RenderSegLoop (void)
 	{
 	    // calculate texture offset
 	    angle = (rw_centerangle + xtoviewangle[rw_x])>>ANGLETOFINESHIFT;
+
+	    // JWh - if the line is almost aligned with the camera, the
+	    // angle is undefined. Prevent an overflow. Issue first seen
+	    // in E1M2 headless_count 1097 x 61 y 84
+	    if (angle >= (FINEANGLES / 2)) {
+		angle = 0;
+	    }
+
 	    texturecolumn = rw_offset-FixedMul(finetangent[angle],rw_distance);
 	    texturecolumn >>= FRACBITS;
 	    // calculate lighting
@@ -399,7 +407,7 @@ R_StoreWallRange
     
     // calculate rw_distance for scale calculation
     rw_normalangle = curline->angle + ANG90;
-    offsetangle = abs(rw_normalangle-rw_angle1);
+    offsetangle = abs((int)(rw_normalangle-rw_angle1)); // JWh - abs is signed!
     
     if (offsetangle > ANG90)
 	offsetangle = ANG90;
@@ -621,7 +629,7 @@ R_StoreWallRange
 	offsetangle = rw_normalangle-rw_angle1;
 	
 	if (offsetangle > ANG180)
-	    offsetangle = -offsetangle;
+	    offsetangle = 0-offsetangle; // JWh - MSVC rejects unary minus with unsigned types
 
 	if (offsetangle > ANG90)
 	    offsetangle = ANG90;
diff --git a/headless_doom/r_things.c b/headless_doom/r_things.c
index c201fff..5d9407a 100644
--- a/headless_doom/r_things.c
+++ b/headless_doom/r_things.c
@@ -216,7 +216,8 @@ void R_InitSpriteDefs (char** namelist)
 	//  filling in the frames for whatever is found
 	for (l=start+1 ; l<end ; l++)
 	{
-	    if (*(int *)lumpinfo[l].name == intname)
+	    const int* name_p = (int*) &lumpinfo[l].name; // JWh - aliasing will not matter here
+	    if (name_p[0] == intname)
 	    {
 		frame = lumpinfo[l].name[4] - 'A';
 		rotation = lumpinfo[l].name[5] - '0';
@@ -789,7 +790,7 @@ void R_SortVisSprites (void)
     int			i;
     int			count;
     vissprite_t*	ds;
-    vissprite_t*	best;
+    vissprite_t*	best = NULL; // JWh - ensure initialised
     vissprite_t		unsorted;
     fixed_t		bestscale;
 
diff --git a/headless_doom/s_sound.c b/headless_doom/s_sound.c
index bcfb538..5af70bb 100644
--- a/headless_doom/s_sound.c
+++ b/headless_doom/s_sound.c
@@ -43,6 +43,7 @@ rcsid[] = "$Id: s_sound.c,v 1.6 1997/02/03 22:45:12 b1 Exp $";
 
 #include "doomstat.h"
 
+#include "m_misc.h" // JWh - for Lump_Snprintf
 
 // Purpose?
 const char snd_prefixen[]
@@ -164,7 +165,7 @@ void S_Init
 {  
   int		i;
 
-  fprintf( stderr, "S_Init: default sfx volume %d\n", sfxVolume);
+  // fprintf( stderr, "S_Init: default sfx volume %d\n", sfxVolume); // JWh - debug to stdout only
 
   // Whatever these did with DMX, these are rather dummies now.
   I_SetChannels();
@@ -365,6 +366,7 @@ S_StartSoundAtVolume
     sfx->lumpnum = I_GetSfxLumpNum(sfx);
 
 #ifndef SNDSRV
+#ifndef HEADLESS
   // cache data if necessary
   if (!sfx->data)
   {
@@ -378,6 +380,7 @@ S_StartSoundAtVolume
     //       sfx_id, sfx->lumpnum, (int)sfx->data );
     
   }
+#endif
 #endif
   
   // increase the usefulness
@@ -651,7 +654,7 @@ S_ChangeMusic
 ( int			musicnum,
   int			looping )
 {
-    musicinfo_t*	music;
+    musicinfo_t*	music = NULL; // JWh - always initialised
     char		namebuf[9];
 
     if ( (musicnum <= mus_None)
@@ -671,7 +674,7 @@ S_ChangeMusic
     // get lumpnum if neccessary
     if (!music->lumpnum)
     {
-	sprintf(namebuf, "d_%s", music->name);
+	M_LumpSprintf(namebuf, "d_%s", music->name);
 	music->lumpnum = W_GetNumForName(namebuf);
     }
 
diff --git a/headless_doom/st_stuff.c b/headless_doom/st_stuff.c
index 16f2e3f..848c5a6 100644
--- a/headless_doom/st_stuff.c
+++ b/headless_doom/st_stuff.c
@@ -61,6 +61,8 @@ rcsid[] = "$Id: st_stuff.c,v 1.6 1997/02/03 22:45:13 b1 Exp $";
 #include "dstrings.h"
 #include "sounds.h"
 
+#include "m_misc.h" // JWh - for M_LumpSprintf
+
 //
 // STATUS BAR DATA
 //
@@ -1133,10 +1135,10 @@ void ST_loadGraphics(void)
     // Load the numbers, tall and short
     for (i=0;i<10;i++)
     {
-	sprintf(namebuf, "STTNUM%d", i);
+	M_LumpSprintf(namebuf, "STTNUM%d", i);
 	tallnum[i] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
 
-	sprintf(namebuf, "STYSNUM%d", i);
+	M_LumpSprintf(namebuf, "STYSNUM%d", i);
 	shortnum[i] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
     }
 
@@ -1147,7 +1149,7 @@ void ST_loadGraphics(void)
     // key cards
     for (i=0;i<NUMCARDS;i++)
     {
-	sprintf(namebuf, "STKEYS%d", i);
+	M_LumpSprintf(namebuf, "STKEYS%d", i);
 	keys[i] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
     }
 
@@ -1157,7 +1159,7 @@ void ST_loadGraphics(void)
     // arms ownership widgets
     for (i=0;i<6;i++)
     {
-	sprintf(namebuf, "STGNUM%d", i+2);
+	M_LumpSprintf(namebuf, "STGNUM%d", i+2);
 
 	// gray #
 	arms[i][0] = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
@@ -1167,7 +1169,7 @@ void ST_loadGraphics(void)
     }
 
     // face backgrounds for different color players
-    sprintf(namebuf, "STFB%d", consoleplayer);
+    M_LumpSprintf(namebuf, "STFB%d", consoleplayer);
     faceback = (patch_t *) W_CacheLumpName(namebuf, PU_STATIC);
 
     // status bar background bits
@@ -1179,18 +1181,18 @@ void ST_loadGraphics(void)
     {
 	for (j=0;j<ST_NUMSTRAIGHTFACES;j++)
 	{
-	    sprintf(namebuf, "STFST%d%d", i, j);
+	    M_LumpSprintf(namebuf, "STFST%d%d", i, j);
 	    faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
 	}
-	sprintf(namebuf, "STFTR%d0", i);	// turn right
+	M_LumpSprintf(namebuf, "STFTR%d0", i);	// turn right
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
-	sprintf(namebuf, "STFTL%d0", i);	// turn left
+	M_LumpSprintf(namebuf, "STFTL%d0", i);	// turn left
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
-	sprintf(namebuf, "STFOUCH%d", i);	// ouch!
+	M_LumpSprintf(namebuf, "STFOUCH%d", i);	// ouch!
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
-	sprintf(namebuf, "STFEVL%d", i);	// evil grin ;)
+	M_LumpSprintf(namebuf, "STFEVL%d", i);	// evil grin ;)
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
-	sprintf(namebuf, "STFKILL%d", i);	// pissed off
+	M_LumpSprintf(namebuf, "STFKILL%d", i);	// pissed off
 	faces[facenum++] = W_CacheLumpName(namebuf, PU_STATIC);
     }
     faces[facenum++] = W_CacheLumpName("STFGOD0", PU_STATIC);
diff --git a/headless_doom/timing.c b/headless_doom/timing.c
new file mode 100644
index 0000000..88fb8ef
--- /dev/null
+++ b/headless_doom/timing.c
@@ -0,0 +1,35 @@
+
+#include "headless.h"
+
+#ifdef _MSC_VER
+#include <Windows.h>
+uint64_t M_GetTimeMicroseconds() {
+    SYSTEMTIME st;
+    FILETIME ft;
+    uint64_t time;
+    // get time in hour:minute:second form
+    GetSystemTime(&st);
+    // convert to a count of 100 nanosecond intervals since some epoch
+    SystemTimeToFileTime(&st, &ft);
+    // store in a single 64-bit value
+    time = ((uint64_t) ft.dwLowDateTime);
+    time += ((uint64_t) ft.dwHighDateTime) << 32;
+    // convert to microseconds
+    return time / 10;
+}
+#else
+#include <sys/time.h>
+#include <stddef.h>
+uint64_t M_GetTimeMicroseconds() {
+    struct timeval st;
+    uint64_t time;
+    // get time in microseconds
+    gettimeofday(&st, NULL);
+    // store in a single 64-bit value
+    time = ((uint64_t)st.tv_sec) * 1000000;
+    time += (uint64_t)st.tv_usec;
+    // convert to microseconds
+    return time;
+}
+#endif
+
diff --git a/headless_doom/w_wad.c b/headless_doom/w_wad.c
index 178f5cb..f38801a 100644
--- a/headless_doom/w_wad.c
+++ b/headless_doom/w_wad.c
@@ -38,6 +38,12 @@ rcsid[] = "$Id: w_wad.c,v 1.5 1997/02/03 16:47:57 b1 Exp $";
 #define O_BINARY		0
 #endif
 
+#include <ctype.h> // JWh - for 'toupper'
+#include <string.h> // JWh - for 'strlen'
+#ifdef HEADLESS
+#include "headless.h" // for alloca
+#endif
+
 #include "doomtype.h"
 #include "m_swap.h"
 #include "i_system.h"
@@ -66,19 +72,19 @@ void**			lumpcache;
 
 #define strcmpi	strcasecmp
 
-void strupr (char* s)
+void my_strupr (char* s) // JWh - strupr is not always available in the C library
 {
     while (*s) { *s = toupper(*s); s++; }
 }
 
-int filelength (int handle) 
+int filelength (FILE* handle)  // JWh - use stdio file functions
 { 
-    struct stat	fileinfo;
+    int size;
     
-    if (fstat (handle,&fileinfo) == -1)
-	I_Error ("Error fstating");
-
-    return fileinfo.st_size;
+    fseek (handle, 0, SEEK_END);
+    size = (int) ftell (handle);
+    fseek (handle, 0, SEEK_SET);
+    return size;
 }
 
 
@@ -143,12 +149,12 @@ void W_AddFile (char *filename)
     wadinfo_t		header;
     lumpinfo_t*		lump_p;
     unsigned		i;
-    int			handle;
+    FILE*	handle;
     int			length;
     int			startlump;
     filelump_t*		fileinfo;
     filelump_t		singleinfo;
-    int			storehandle;
+    FILE*	storehandle;
     
     // open the file and add to directory
 
@@ -160,7 +166,7 @@ void W_AddFile (char *filename)
 	reloadlump = numlumps;
     }
 		
-    if ( (handle = open (filename,O_RDONLY | O_BINARY)) == -1)
+    if ( (handle = fopen (filename, "rb")) == NULL) // JWh - use stdio file functions
     {
 	printf (" couldn't open %s\n",filename);
 	return;
@@ -181,7 +187,7 @@ void W_AddFile (char *filename)
     else 
     {
 	// WAD file
-	read (handle, &header, sizeof(header));
+	fread (&header, 1, sizeof(header), handle); // JWh - use stdio file functions
 	if (strncmp(header.identification,"IWAD",4))
 	{
 	    // Homebrew levels?
@@ -197,8 +203,8 @@ void W_AddFile (char *filename)
 	header.infotableofs = LONG(header.infotableofs);
 	length = header.numlumps*sizeof(filelump_t);
 	fileinfo = alloca (length);
-	lseek (handle, header.infotableofs, SEEK_SET);
-	read (handle, fileinfo, length);
+	fseek (handle, header.infotableofs, SEEK_SET); // JWh - use stdio file functions
+	fread (fileinfo, 1, length, handle);           // JWh - use stdio file functions
 	numlumps += header.numlumps;
     }
 
@@ -211,7 +217,7 @@ void W_AddFile (char *filename)
 
     lump_p = &lumpinfo[startlump];
 	
-    storehandle = reloadname ? -1 : handle;
+    storehandle = reloadname ? NULL : handle; // JWh - use stdio file functions
 	
     for (i=startlump ; i<numlumps ; i++,lump_p++, fileinfo++)
     {
@@ -222,7 +228,7 @@ void W_AddFile (char *filename)
     }
 	
     if (reloadname)
-	close (handle);
+	fclose (handle);
 }
 
 
@@ -239,23 +245,23 @@ void W_Reload (void)
     int			lumpcount;
     lumpinfo_t*		lump_p;
     unsigned		i;
-    int			handle;
+    FILE*	handle;
     int			length;
     filelump_t*		fileinfo;
 	
     if (!reloadname)
 	return;
 		
-    if ( (handle = open (reloadname,O_RDONLY | O_BINARY)) == -1)
+    if ( (handle = fopen (reloadname, "rb")) == NULL) // JWh - use stdio file functions
 	I_Error ("W_Reload: couldn't open %s",reloadname);
 
-    read (handle, &header, sizeof(header));
+    fread (&header, 1, sizeof(header), handle);
     lumpcount = LONG(header.numlumps);
     header.infotableofs = LONG(header.infotableofs);
     length = lumpcount*sizeof(filelump_t);
     fileinfo = alloca (length);
-    lseek (handle, header.infotableofs, SEEK_SET);
-    read (handle, fileinfo, length);
+    fseek (handle, header.infotableofs, SEEK_SET);
+    fread (fileinfo, 1, length, handle);
     
     // Fill in lumpinfo
     lump_p = &lumpinfo[reloadlump];
@@ -271,7 +277,7 @@ void W_Reload (void)
 	lump_p->size = LONG(fileinfo->size);
     }
 	
-    close (handle);
+    fclose (handle);
 }
 
 
@@ -367,7 +373,7 @@ int W_CheckNumForName (char* name)
     name8.s[8] = 0;
 
     // case insensitive
-    strupr (name8.s);		
+    my_strupr (name8.s);		// JWh - strupr not always available
 
     v1 = name8.x[0];
     v2 = name8.x[1];
@@ -378,8 +384,8 @@ int W_CheckNumForName (char* name)
 
     while (lump_p-- != lumpinfo)
     {
-	if ( *(int *)lump_p->name == v1
-	     && *(int *)&lump_p->name[4] == v2)
+	const int* name_p = (int*) lump_p->name; // JWh - aliasing will not matter here
+	if (name_p[0] == v1 && name_p[1] == v2)
 	{
 	    return lump_p - lumpinfo;
 	}
@@ -435,7 +441,7 @@ W_ReadLump
 {
     int		c;
     lumpinfo_t*	l;
-    int		handle;
+    FILE* handle;
 	
     if (lump >= numlumps)
 	I_Error ("W_ReadLump: %i >= numlumps",lump);
@@ -444,24 +450,24 @@ W_ReadLump
 	
     // ??? I_BeginRead ();
 	
-    if (l->handle == -1)
+    if (l->handle == NULL)
     {
 	// reloadable file, so use open / read / close
-	if ( (handle = open (reloadname,O_RDONLY | O_BINARY)) == -1)
+	if ( (handle = fopen (reloadname, "rb")) == NULL) // JWh - use stdio file functions
 	    I_Error ("W_ReadLump: couldn't open %s",reloadname);
     }
     else
 	handle = l->handle;
 		
-    lseek (handle, l->position, SEEK_SET);
-    c = read (handle, dest, l->size);
+    fseek (handle, l->position, SEEK_SET);
+    c = fread (dest, 1, l->size, handle);
 
     if (c < l->size)
 	I_Error ("W_ReadLump: only read %i of %i on lump %i",
 		 c,l->size,lump);	
 
-    if (l->handle == -1)
-	close (handle);
+    if (l->handle == NULL)
+	fclose (handle);
 		
     // ??? I_EndRead ();
 }
diff --git a/headless_doom/w_wad.h b/headless_doom/w_wad.h
index db1faaa..fd496a6 100644
--- a/headless_doom/w_wad.h
+++ b/headless_doom/w_wad.h
@@ -56,7 +56,7 @@ typedef struct
 typedef struct
 {
     char	name[8];
-    int		handle;
+    FILE*   handle;
     int		position;
     int		size;
 } lumpinfo_t;
diff --git a/headless_doom/wi_stuff.c b/headless_doom/wi_stuff.c
index 01502c8..90f6c9d 100644
--- a/headless_doom/wi_stuff.c
+++ b/headless_doom/wi_stuff.c
@@ -42,6 +42,8 @@ rcsid[] = "$Id: wi_stuff.c,v 1.7 1997/02/03 22:45:13 b1 Exp $";
 
 #include "doomstat.h"
 
+#include "m_misc.h" // JWh - for M_LumpSprintf
+
 // Data.
 #include "sounds.h"
 
@@ -1545,7 +1547,7 @@ void WI_loadData(void)
     if (gamemode == commercial)
 	strcpy(name, "INTERPIC");
     else 
-	sprintf(name, "WIMAP%d", wbs->epsd);
+	M_LumpSprintf(name, "WIMAP%d", wbs->epsd);
     
     if ( gamemode == retail )
     {
@@ -1576,7 +1578,7 @@ void WI_loadData(void)
 				       PU_STATIC, 0);
 	for (i=0 ; i<NUMCMAPS ; i++)
 	{								
-	    sprintf(name, "CWILV%2.2d", i);
+	    M_LumpSprintf(name, "CWILV%2.2d", i);
 	    lnames[i] = W_CacheLumpName(name, PU_STATIC);
 	}					
     }
@@ -1586,7 +1588,7 @@ void WI_loadData(void)
 				       PU_STATIC, 0);
 	for (i=0 ; i<NUMMAPS ; i++)
 	{
-	    sprintf(name, "WILV%d%d", wbs->epsd, i);
+	    M_LumpSprintf(name, "WILV%d%d", wbs->epsd, i);
 	    lnames[i] = W_CacheLumpName(name, PU_STATIC);
 	}
 
@@ -1610,7 +1612,7 @@ void WI_loadData(void)
 		    if (wbs->epsd != 1 || j != 8) 
 		    {
 			// animations
-			sprintf(name, "WIA%d%.2d%.2d", wbs->epsd, j, i);  
+			M_LumpSprintf(name, "WIA%d%.2d%.2d", wbs->epsd, j, i);  
 			a->p[i] = W_CacheLumpName(name, PU_STATIC);
 		    }
 		    else
@@ -1629,7 +1631,7 @@ void WI_loadData(void)
     for (i=0;i<10;i++)
     {
 	 // numbers 0-9
-	sprintf(name, "WINUM%d", i);     
+	M_LumpSprintf(name, "WINUM%d", i);     
 	num[i] = W_CacheLumpName(name, PU_STATIC);
     }
 
@@ -1695,11 +1697,11 @@ void WI_loadData(void)
     for (i=0 ; i<MAXPLAYERS ; i++)
     {
 	// "1,2,3,4"
-	sprintf(name, "STPB%d", i);      
+	M_LumpSprintf(name, "STPB%d", i);      
 	p[i] = W_CacheLumpName(name, PU_STATIC);
 
 	// "1,2,3,4"
-	sprintf(name, "WIBP%d", i+1);     
+	M_LumpSprintf(name, "WIBP%d", i+1);     
 	bp[i] = W_CacheLumpName(name, PU_STATIC);
     }
 
diff --git a/headless_doom/z_zone.c b/headless_doom/z_zone.c
index 4345485..4c17808 100644
--- a/headless_doom/z_zone.c
+++ b/headless_doom/z_zone.c
@@ -192,7 +192,7 @@ Z_Malloc
     memblock_t* newblock;
     memblock_t*	base;
 
-    size = (size + 3) & ~3;
+    size = (size + sizeof(void*) - 1) & ~(sizeof(void*) - 1); // JWh - 64-bit compatibility
     
     // scan through the block list,
     // looking for the first free block
@@ -437,7 +437,7 @@ Z_ChangeTag2
     if (block->id != ZONEID)
 	I_Error ("Z_ChangeTag: freed a pointer without ZONEID");
 
-    if (tag >= PU_PURGELEVEL && (unsigned)block->user < 0x100)
+    if (tag >= PU_PURGELEVEL && (unsigned)((intptr_t)block->user) < 0x100) // JWh - 64-bit compat
 	I_Error ("Z_ChangeTag: an owner is required for purgable blocks");
 
     block->tag = tag;
diff --git a/pic.png b/pic.png
new file mode 100644
index 0000000..133acf0
Binary files /dev/null and b/pic.png differ
